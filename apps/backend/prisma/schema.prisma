// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ----------------------------------------------------
// ENUMS
// ----------------------------------------------------
enum Role {
  SUPER_ADMIN
  SUPER_VENDEDOR
  VENDEDOR
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
  ANNULLED // Estado para ventas anuladas
}

enum PaymentMethod {
  YAPE
  PLIN
  EFECTIVO
  TRANSFERENCIA // Añadido para compras/egresos
  CHEQUE        // Añadido para compras/egresos
  CREDITO       // Añadido para compras/egresos
}

enum DeliveryMethod {
  OFICINA
  DELIVERY
  ENVIO
}

enum StockMovementType {
  ENTRADA
  SALIDA
  AJUSTE
}

enum StockMovementSubType {
  COMPRA
  VENTA
  DEVOLUCION_CLIENTE
  DEVOLUCION_PROVEEDOR
  AJUSTE_MANUAL
  ANULACION_VENTA
  LOTE_LEGACY
  AJUSTE_COMPRA_EDITADA
}

enum CashMovementType {
  ENTRADA
  SALIDA
  APERTURA_CAJA // Si necesitas arqueos
}

enum PurchaseStatus {
  REGISTRADA
  RECIBIDA_PARCIAL
  RECIBIDA_COMPLETA
  ANULADA
}

enum LotStatus {
  ACTIVO    // Tiene stock disponible
  AGOTADO   // Stock llegó a cero por ventas/ajustes
  VENCIDO   // Si aplica fecha de vencimiento
  ELIMINADO // Si se elimina manualmente
}


// ----------------------------------------------------
// MODELOS PRINCIPALES
// ----------------------------------------------------

// 1. USUARIO (Para el panel)
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   // Necesitamos hashear esto en el backend
  name      String?
  role      Role     @default(VENDEDOR)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones inversas
  salesRegistered    Sale[]           @relation("SaleRegisteredBy")
  expensesRegistered Expense[]
  purchasesMade      Purchase[]
  stockMovements     StockMovement[]
  cashMovements      CashMovement[]
}

// 2. CATEGORÍA DE PRODUCTO
model Category {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relación inversa
  products Product[]
}

// 3. PRODUCTO
model Product {
  id              String    @id @default(cuid())
  name            String
  slug            String    @unique // Para URLs amigables
  description     String?   @db.Text
  price           Decimal   @db.Decimal(10, 2) // Precio de venta
  originalPrice   Decimal?  @db.Decimal(10, 2) // Precio antes de oferta
  acquisitionCost Decimal?  @db.Decimal(10, 2) // Costo promedio (actualizado por lotes) o fijo
  stock           Int       @default(0) // Stock total (calculado desde lotes)
  code            String?   @unique // SKU
  imageUrl        String?
  imageUrl2       String?
  imageUrl3       String?
  imageUrl4       String?
  isFeatured      Boolean   @default(false)
  tags            String[]  // Para búsqueda/filtros
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Campos legacy para cálculo histórico si no hay lotes
  stockInicial        Int?
  precioCompraInicial Decimal? @db.Decimal(10, 2)

  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  // Relaciones inversas
  saleItems      SaleItem[]
  purchaseItems  PurchaseItem[]
  stockLots      StockLot[]
  stockMovements StockMovement[]
}

// 4. VENTA (Order en el schema anterior)
model Sale {
  id               String         @id @default(cuid())
  status           OrderStatus    @default(PENDING)
  totalAmount      Decimal        @db.Decimal(10, 2) // Incluye deliveryCost
  subtotalAmount   Decimal        @db.Decimal(10, 2) // Solo productos
  totalCost        Decimal?       @db.Decimal(10, 2) // Costo real FIFO calculado post-venta
  profit           Decimal?       @db.Decimal(10, 2) // Ganancia real calculada post-venta
  paymentMethod    PaymentMethod
  deliveryMethod   DeliveryMethod
  deliveryCost     Decimal        @default(0) @db.Decimal(10, 2)
  deliveryLocation String?

  // Info Cliente
  customerName    String
  customerPhone   String?
  // customerAddress String? // Lo tenías en tu código, ¿lo necesitas?

  soldById String // Email o ID del User
  soldBy   User   @relation("SaleRegisteredBy", fields: [soldById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relación inversa
  items     SaleItem[]
  // Lotes procesados (info resumida podría ir aquí o solo en movimientos)
  lotesInfo Json? // { productId: string, loteId: string, cantidad: number, costo: Decimal }[]
}

// 5. ITEM DE VENTA (Tabla de unión)
model SaleItem {
  id        String  @id @default(cuid())
  quantity  Int
  price     Decimal @db.Decimal(10, 2) // Precio al momento de la venta
  cost      Decimal @db.Decimal(10, 2) // Costo unitario al momento de la venta (del lote FIFO)

  saleId    String
  sale      Sale    @relation(fields: [saleId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id]) // No eliminar producto si está en una venta

  @@unique([saleId, productId])
}

// 6. EGRESO
model Expense {
  id          String   @id @default(cuid())
  description String
  amount      Decimal  @db.Decimal(10, 2)
  category    String   // Podría ser un Enum si las categorías son fijas
  date        DateTime // Fecha del egreso
  notes       String?

  registeredById String
  registeredBy User @relation(fields: [registeredById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 7. PROVEEDOR
model Supplier {
  id        String   @id @default(cuid())
  name      String   @unique
  contact   String?
  phone     String?
  email     String?  @unique
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones inversas
  purchases Purchase[]
  stockLots StockLot[]
}

// 8. COMPRA
model Purchase {
  id            String         @id @default(cuid())
  purchaseDate  DateTime
  invoiceNumber String?
  paymentMethod PaymentMethod?
  notes         String?
  totalAmount   Decimal      @db.Decimal(10, 2) // Total pagado al proveedor
  status        PurchaseStatus @default(REGISTRADA)

  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id])

  registeredById String
  registeredBy User @relation(fields: [registeredById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones inversas
  items     PurchaseItem[]
  stockLots StockLot[] // Lotes generados por esta compra
}

// 9. ITEM DE COMPRA (Tabla de unión)
model PurchaseItem {
  id           String  @id @default(cuid())
  quantity     Int
  purchasePrice Decimal @db.Decimal(10, 2) // Costo unitario de compra

  purchaseId String
  purchase   Purchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  // Info del lote específico para este item (puede haber varios items del mismo producto en lotes diferentes)
  loteId          String? // ID único del lote generado
  fechaVencimiento DateTime?

  @@unique([purchaseId, productId, loteId]) // Asegura unicidad si se manejan lotes aquí
}


// ----------------------------------------------------
// MODELOS DE INVENTARIO Y CAJA (PARA TRAZABILIDAD)
// ----------------------------------------------------

// 10. LOTE DE STOCK (FIFO)
model StockLot {
  id              String     @id @default(cuid())
  loteId          String     @unique // Identificador legible (ej. LOTE-001, o generado)
  quantity        Int        // Cantidad restante en este lote
  originalQuantity Int     // Cantidad con la que ingresó el lote
  costPerUnit     Decimal    @db.Decimal(10, 2)
  entryDate       DateTime   @default(now())
  expiryDate      DateTime?
  status          LotStatus  @default(ACTIVO)
  isLegacy        Boolean    @default(false) // Para lotes creados desde stock inicial

  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  purchaseId String?
  purchase   Purchase? @relation(fields: [purchaseId], references: [id], onDelete: SetNull) // Compra que originó el lote

  supplierId String?
  supplier   Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull) // Proveedor del lote

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relación inversa
  stockMovements StockMovement[]
}

// 11. MOVIMIENTO DE INVENTARIO
model StockMovement {
  id            String               @id @default(cuid())
  quantity      Int                  // Cantidad movida (+ para entrada, - para salida)
  type          StockMovementType
  subType       StockMovementSubType?
  costPerUnit   Decimal?             @db.Decimal(10, 2) // Costo al momento del movimiento
  totalCost     Decimal?             @db.Decimal(10, 2)
  notes         String?
  referenceId   String?              // ID de la Venta, Compra, Ajuste, etc.
  date          DateTime             @default(now())

  productId String
  product   Product @relation(fields: [productId], references: [id])

  loteId String? // ID del lote afectado (cuid de StockLot)
  lote   StockLot? @relation(fields: [loteId], references: [id], onDelete: SetNull)

  userId String
  user   User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
}

// 12. MOVIMIENTO DE CAJA
model CashMovement {
  id           String           @id @default(cuid())
  type         CashMovementType
  amount       Decimal          @db.Decimal(10, 2)
  category     String?          // Ej. Venta, Compra, Gasto Operativo, etc.
  description  String
  paymentMethod PaymentMethod?
  referenceId  String?          // ID de la Venta, Compra, Egreso, etc.
  date         DateTime         @default(now())
  previousBalance Decimal       @db.Decimal(12, 2) // Saldo antes de este movimiento
  newBalance      Decimal       @db.Decimal(12, 2) // Saldo después de este movimiento

  userId String
  user   User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
}

